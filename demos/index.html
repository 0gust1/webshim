<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta charset="utf-8"/>
	<link href="css/styles.css" rel="stylesheet" />
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
	
	<script src="js-webshim/minified/extras/modernizr-1.7.min.js"></script>
	
	<script src="js-webshim/minified/polyfiller.js"></script>
	<script src="demo-js/demo.js"></script>
    <script class="example">
		//load all polyfill features
		$.webshims.polyfill();
		
    </script>
	
	<title>Webshims lib - The capability-based polyfill-loading JS library</title>
	    
</head>

<body class="home">

		<header>
			<hgroup>
				<h1>Webshims Lib.</h1>
				<h2>Polyfill only the incapable browsers</h2>
			</hgroup>
			<nav>
				
			</nav>
		</header>
		<div class="main">
			<section>
				<div class="home-box about-box">
					<p>Webshims Lib is a DOM extension helper which <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">polyfills</a> the <a href="http://www.brucelawson.co.uk/2010/meet-newt-new-exciting-web-technologies/">latest and greatest web features</a> in browsers that don't support them natively. It is built on top of <a href="http://jquery.com/">jQuery 1.4.4+ / jQuery 1.5.1+</a> and <a href="http://www.modernizr.com/">Modernizr 1.7+</a>.</p>
				</div>
				<div class="home-box download-box">
					<p>
						<a href="http://github.com/aFarkas/webshim/downloads" class="download-button">
							<strong>Download Webshims Lib</strong>
						</a>
					</p>
				</div>
				<div class="home-box concept-box">
				<h3>Main concepts</h3>
					<ul>
						<li><strong>Capability based loading:</strong> the more features a browser supports natively, the more lightweight webshims will be</li>
						<li><strong>Modular feature implementation:</strong> Only load features that you need for your application.</li>
						<li><strong>Future-proof feature detection:</strong> We try to feature detect everything instead of browser sniffing to be more future proof</li>
						<li><strong>Almost pure native and accurate APIs</strong> Helps you to learn HTML5 (Markup-/DOM/JS-APIs) and to build useful abstractions and extensions on top of the standard. Documentation is the specification (e.g. <a href="http://dev.w3.org/html5/html-author/">HTML5 W3C Specification</a>)</li>
					</ul>
				</div>
				<div class="feature-example home-box">
					<h3>What makes webshims lib different?</h3>
					<div class="inner-box">
						<p>Did you ever try to dynamically set or get the placeholder or the value attribute of a text input with one of the other placeholder shims? With many of them it doesn't properly work. Webshims strives to provide a uniform and standards-compliant API in every environment.</p>
						<p>The following text input uses the html5 placeholder attribute:</p>
						<form action="#">
							<input class="text" name="placeholder" id="placeholder" placeholder="change me" />
						</form>
						<p>If you're viewing this page in a browser that doesn't support placeholder, Webshims has added this functionality via Javascript, and in a way that preserves your ability to work with the element's properties dynamically:</p>
						<code>$("#placeholder").attr("placeholder", "<input value="test text" class="text" id="placeholder-text" />");</code> <button>run code</button>
						<div class="hidden-explanation">
							<p>Being able to change the placeholder of an input element dynamically isn't  a huge deal, but it shows how webshims lib works. With few exceptions, you won't be able to tell the difference between a shim and a native implementation. In some cases, the shim will even be more standards compliant than some browsers' native implementations.</p>
							<p>The placeholder polyfill also works with getting and setting the value property (many other placeholder polyfills don't support this properly):</p>
							<ul>
								<li><code>$("#placeholder").attr('value')</code></li>
								<li><code>$("#placeholder").val()</code></li>
								<li><code>$("#placeholder").attr('value', 'new value')</code></li>
								<li><code>$("#placeholder").val('new value')</code></li>
							</ul>
						</div>
					</div>
				</div>
				<div class="home-box supported-browser-box">
					<h3>Supported Browsers</h3>
					<ul>
						<li>IE6+</li>
						<li>Firefox 3.0+</li>
						<li>Safari 4+</li>
						<li>Safari for iOS 4.2</li>
						<li>Chrome 9.0+</li>
						<li>Opera 10.54+</li>
					</ul>
					
				</div>
				
			</section>
			<section class="feature-overview">
				<hgroup>
					<h2>Features / Demos</h2>
				</hgroup>
				<div>
					<article>
						<h3><a href="demos/shiv.html">Semantic Structure: Shiv solution</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/es5.html">ES5/JavaScript 1.8.5</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/json-storage.html">JSON.parse / JSON.stringify &amp; localStorage / sessionStorage</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/geolocation.html">Geolocation</a></h3>
					</article>
					
					
					<article>
						<h3><a href="demos/canvas.html">Canvas</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/webforms.html">HTML5 forms / Webforms 2</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/details.html">interactive elements: details &amp; summary</a></h3>
					</article>
				</div>	
			</section>
			<section>
				<hgroup>
					<h2>How to</h2>
				</hgroup>
				<div class="accordion">
				<h3 id="quick-install" class="button">Easy &amp; simple Quick install</h3>
				<div class="panel">
<code class="block">
//reference the base script
&lt;script src="js-webshim/minified/polyfiller.js"&gt;&lt;/script&gt;
	
&lt;script&gt;
	//implement all unsupported features
	$.webshims.polyfill();
	//or load only specific features you need
	//$.webshims.polyfill('forms json-storage');
	
	$(function(){
	//use all implemented API-features on DOM-ready
	});
&lt;/script&gt;		
</code>
				</div>
	
				<h3 id="embed-polyfill" class="button">Embedding and configuring the script</h3>
				<div class="panel">
					<ul>
						<li>Take the 'js-webshim' folder and add it to your project. (You will find a minified and a dev folder there.)</li>
						<li>Include the polyfiller.js into your HTML page. You can concatenate this file with your other js and rename. Don't forget to also include <a href="http://jquery.com">jQuery</a> and <a href="http://www.modernizr.com/">Modernizr</a>.</li>
						<li>call the polyfill method</li>
					</ul>
				
<code class="block">
&lt;script src="js/jquery-1.5.1.js"&gt;&lt;/script&gt;
&lt;script src="js/modernizr.js"&gt;&lt;/script&gt;
&lt;script src="js-webshim/minified/polyfiller.js"&gt;&lt;/script&gt;


&lt;script&gt;
	//load and implement all unsupported features
	$.webshims.polyfill();
&lt;/script&gt;	
</code>
				
						<p>The polyfill method can also take a whitespace-separated list of several features.</p>
<code class="block">
//load and implement json-storage and geolocation features, if they aren't supported
$.webshims.polyfill('json-storage geolocation');
</code>					
						<h3>List of features</h3>
						
						<ul>
							<li><code>json-storage</code>*</li>
							<li><code>es5</code>*</li>
							<li><code>geolocation</code>*</li>
							<li><code>canvas</code>*</li>
							<li><code>forms</code>*</li>
							<li><code>forms-ext</code></li>
							<li><code>details</code></li>
						</ul>
						<p>The polyfill-method can also take a keyword called <code>lightweight</code>, which will load a filesize-/feature balanced profile</p>
						<p><small>With an * marked features are part of the lightweight profile</small></p>
	
<code class="block">
//load and implement all unsupported features from the lightweight profile
$.webshims.polyfill('lightweight');
</code>			
						<p>If you have any trouble setting up Webshims lib, set <code>$.webshims.debug</code> to true and open your console:</p>
<code class="block">							
&lt;script&gt;
	$.webshims.debug = true;
	$.webshims.polyfill();
&lt;/script&gt;	
</code>			
					<h3>High Performance loading using combo-handler service</h3>
					<p>Webshims lib supports generating a combohandler - url. Simply pass true or your combohandler options as the second argument. The defaults are fine to use in conjunction with the defaults of the <a href="http://code.google.com/p/minify/">minify - project</a>.</p>
<code class="block">
//loads all features with a combohandler
$.webshims.polyfill(true);
//loads lightweight with a combohandler
$.webshims.polyfill('lightweight', true);
//loads json-storage and geolocation as a combohandler
$.webshims.polyfill('js-storage geolocation', true);
</code>
					<p>You can configure the generated combohandler using the following options</p>
					<ul>
						<li><strong>base</strong>: (default: '/min/f=') The base path to your combohandler-middleware.</li>
						<li><strong>seperator</strong>: (default: ',') the seperator between each js-source</li>
						<li><strong>maxFiles</strong>: (default: 10) the maximum files, that are combined in one combohandler</li>
						<li><strong>scriptPath</strong>: (default: dynamically computed absolute script-path to your shims-folder without a starting slash)</li>
					</ul>
<code class="block">
//loads json-storage and geolocation as a combohandler
$.webshims.polyfill('js-storage geolocation', true);
//would load in IE7: /min/f=path-to-shims/json-storage.js,path-to-shims/geolocation.js
//would load in IE8: /min/f=path-to-shims/geolocation.js
//would load in IE9 and other browsers: nothing :-)

$.webshims.polyfill('js-storage geolocation', {
	seperator: '&',
	base: '/minify.jsp?scripts='
});
//would load in IE7: /minify.jsp?scripts=path-to-shims/json-storage.js&path-to-shims/geolocation.js
//would load in IE8: /minify.jsp?scripts=path-to-shims/geolocation.js
//would load in IE9 and other browsers: nothing :-)
</code>			
				
				</div>
				<h3 id="polyfill-ready" class="button">Fire when ready</h3>
				<div class="panel">
				<p>Not every feature is ready immediately in all browsers; some shims might take time to load before you can use them. You can use one of jQuery's <code>ready</code> methods to delay working with elements until the DOM and any necessary shims are ready.</p>
<code class="block">
$(function(){
	//work with DOM + all implemented features
});

$(doument).ready(function(){
	//work with DOM + all features
});
</code>		
	
			
					<p>If you want to use a feature as soon as possible, you can use <code>$.webshims.ready</code> and pass the feature name(s) and a callback function:</p>
<code class="block">
$.webshims.ready('geolocation json-storage', function(){
	//work with geolocation, JSON and localStorage
});
</code>	
					<p>Note that this callback function may be called before DOM-Ready. If you want to use a feature after DOM-Ready, simply pass the string 'DOM':</p>
<code class="block">
$.webshims.ready('DOM canvas', function(){
	//work with canvas in the document
});
</code>	
				</div>
				<h3 id="polyfill-options" class="button">Setting feature-specific options</h3>
				<div class="panel">
					<p>Some features have additional options which can be configured with the <code>$.webshims.setOptions</code> method. <code>setOptions</code> should always be called before the <code>polyfill</code> method:</p>
<code class="block">
$.webshims.setOptions('canvas', {
	type: "flash" //use flashcanvas instead of excanvas as polyfill
});
</code>		
				
					<p><code>setOptions</code> can also take a single options parameter:</p>
<code class="block">
$.webshims.setOptions({
	//configure canvas-shim
	canvas: {
		type: "flash" // use flashcanvas instead of excanvas as polyfill
	},
	//configure forms-shim
	forms: {
		customMessages: true // implement customValidationMessages
	}
});
</code>	
				</div>
				<h3 id="polyfill-abstractions" class="button">Minor Abstractions to DOM attributes, DOM methods and DOM events</h3>
				<div class="panel">
					<p>Due to the fact that we cannot extend accessors of elements in all browsers, we always use jQuery as an extension-wrapper.</p>
					<ul>
						<li>
							<p><strong>Accessing DOM properties/attribute IDLs</strong>: if the feature allows accessing a specific property, always use jQuery's built-in <code>$.attr</code> method:</p>
<code class="block">
// instead of accessing a property directly (e.g. this.validity), use $.fn.attr 
$(this).attr('validity');
// or:
//$.attr(this, 'validity');
</code>
						</li>
						<li>
							<p><strong>calling a DOM method</strong>: While DOM properties have to be accessed through jQuery's <code>$.attr</code> method, DOM methods are added to DOM elements themselves, so you can call them directly:</p>
<code class="block">
// "this" refers to a DOM element, not a jQuery object
this.checkValidity();
</code>
							<p>Webshims lib also generates a jQuery plugin which wraps the feature, so you can use jQuery too:</p>
<code class="block">
$(this).checkValidity();
</code>
							<p>If you pass a list of nodes and the method doesn't return anything, the method will be called on each element in this list, otherwise it will be called on the first element.</p>
						</li>
						<li>
							<p><strong>binding to events</strong>: Always use jQuery's <code>bind</code> method to register your event handlers. <code>addEventListener</code> won't work in polyfilled browsers. Most events in the HTML5 specification are so-called simple events. Simple events do not bubble. Due to the fact that developers really like event delegation and jQuery cannot distinguish between the event phases (capturing/propagation), we use event capturing in the native implementation and <code>$.fn.trigger</code> in the shim.</p>
							<p>This means that some HTML5 events go down the DOM tree in capable browsers and go up the tree in polyfilled browsers. This can create differences if you are calling <code>event.stopPropagation();</code> or <code>return false;</code> in your event handler. If you only want to prevent the default, don't use <code>return false;</code>, use <code>event.preventDefault();</code> instead.</p>
						</li>
						<li>
							<p><strong>manipulation methods</strong>: To insert new HTML5 content dynamically, use <code>.htmlWebshim()</code>, <code>.appendWebshim()</code>, <code>.prependWebshim()</code>, <code>.afterWebshim()</code>, <code>.beforeWebshim()</code> and <code>.replaceWithWebshim()</code>:</p>
<code class="block">
//three different examples
$('form').appendWebshim('&lt;input type="date" /&gt;');
$('#canvas-box').htmlWebshim('&lt;canvas&gt;&lt;/canvas&gt;');
$('datalist#list select').prependWebshim('&lt;option value="new suggestion item" /&gt;');
</code>
						</li>
					</ul>
					</div>
					<h3 id="implement-polyfill" class="button">How to write a new feature implementation?</h3>
					<div class="panel">
						<p>A Pollyfill is always split into at least two parts. First the test and loader definition, and then the implementation.</p>
		
		<p>Assume there is a new method <code>magicMethod</code> on the window object that we want to polyfill if the browser doesn't provide it. An implementation would look like this:</p>
<code class="block">
$.webshims.addPolyfill('magicMethod', {
	test: function(){
		return ('magicMethod' in window);	
	}
});
// loads magicMethod.js from shim-folder if test returns false
</code>		
		<p>Create a file called magicMethod with your polyfill code and place it in the shim folder:</p>	
<code class="block">
window.magicMethod = function(){
	//your polyfill implementation
};
</code>		

		<p>If your implementation has dependencies on other polyfills/modules, you can add a dependencies property to make sure they're loaded too:</p>
		
<code class="block">
$.webshims.addPolyfill('magicMethod', {
	test: function(){
		return ('magicMethod' in window);	
	},
	dependencies: ['es5', 'json-storage']
});
// load magicMethod.js and its dependencies if test returns false
</code>		
		<p>If your shim has dependencies, you have to register your implementation code with <code>$.webshims.register</code>:</p>	
<code class="block">
jQuery.webshims.register('magicMethod', function($, webshims, window, document, undefined, options){
	//now you can use es5-feature and json-storage feature	
	window.magicMethod = function(){
		//your polyfill implementation
	};
});
</code>	

		<p>In case of a DOM extension, webshims lib comes with some useful extension-methods.</p>
<code class="block">
$.webshims.addPolyfill('mediaelement', {
	test: function(){
		return ('canPlayType' in document.createElement('video'));	
	},
	dependencies: ['dom-support'],
	methodNames: ['play'] //pause, load
});
// load mediaelement.js and DOM extension features from shim folder
// if test returns false and always create a jQuery plugin called play,
// which tries to invoke native or polyfilled play

// listen to 'play' events in the capturing phase
// can use event delegation with jQuery's bind method
$.webshims.capturingEvents(['play']);
</code>

		<p>Now put a mediaelement.js inside of your shim folder and start implementing some features. The <code>dom-support</code> feature of Webshims lib comes with some very useful implementation helpers. Here are two of them:</p>
		<ul>
			<li><code>$.webshims.defineNodeNamesProperty</code> (nodeNames, property, descriptor)</li>
			<li><code>$.webshims.defineNodeNamesBooleanProperty</code> (nodeNames, property, descriptor)</li>
		</ul>
<code class="block">
//wait till the DOM-Extension feature is loaded
jQuery.webshims.register('mediaelement', function($, webshims, window, document, undefined, options){
	//note: webshims refers to jQuery.webshims in this function
	
	//Implements a new IDL property on audio, video called currentTime
	webshims.defineNodeNamesProperty('audio, video', 'currentTime', {
		get: function(){
			//your getter implementation ("this" refers to the element)
		},
		set: function(value){
			//your setter implementation ("this" refers to the element)
		}
	});
	
	//Implements a new constant property called HAVE_CURRENT_DATA on audio, video
	webshims.defineNodenamesProperty('audio, video', 'HAVE_CURRENT_DATA', {
		value: 2
	});
	
	//Implements a new method called play on audio, video
	webshims.defineNodeNamesProperty('audio, video', 'play', {
		value: function(){
			//your play method implementation
			//this refers to the element
		}
	});
	
	
	
	//Implements a new boolean IDL property called controls on audio, video
	//which is reflected by a content attribute
	webshims.defineNodeNamesBooleanProperty('audio, video', 'controls', {
		//set works more like an onSet:
		//you don't have to set the value anymore on the DOM node, only handle true/false values
		set: function(value){
			if(value){
				//show controls for elem
			} else {
				//hide controls for elem
			}
		},
		initAttr: true
	});
});	
</code>
		
					</div>
				</div>
			</section>
			
				
			<section>
				<hgroup>
					<h2>Further Development</h2>
					<h3>Feel free to <a href="https://github.com/aFarkas/webshim#fork_box">fork</a>, <a href="https://github.com/aFarkas/webshim/issues">report issues</a>, develop implementations/features, develop extensions on top of implemented featues or simply use :-).</h3>
				</hgroup>
				
				<ul>
					<li>improve current implementations</li>
					<li><a href="http://www.w3.org/TR/html5/video.html">audio/video</a> implementation (coming in 1.7)</li>
					<li>switching to a third party scriptloader (maybe <a href="https://github.com/SlexAxton/yepnope.js">yepnope</a> (coming in 1.8))</li>
					<li>history (pushState etc.)/hashchange (maybe <a href="https://github.com/balupton/history.js">history.js</a> (coming in 1.9))</li>
					<li>make everything more native (this will be more awsome!!! coming in 2.0)</li>
				</ul>
				
			</section>
		</div>
		<footer>
			<small>
				<strong>Note</strong>: every polyfill is a hack! innovative frontend development is hacky and always will be hacky!
			</small>
		</footer>
<!--[if lte IE 7]>
	<div class="browser-support"> 			
		<div class="browser-support-box"> 				
			Webshims Lib really cares about cross browser support and supports all A-Graded Browsers including IE6 and newest Opera. But I don't care about Styling/Layout issues in IE7- on this demo page.
		</div> 		
	</div>
<![endif]-->
</body>
</html>   
