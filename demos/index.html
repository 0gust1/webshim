<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta charset="utf-8"/>
	<link href="css/styles.css" rel="stylesheet" />
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
	
	<script src="js-webshim/minified/extras/modernizr-custom.js"></script>
	<script src="js-webshim/minified/extras/loaders/sssl.js"></script>
	
	<script src="js-webshim/minified/polyfiller.js"></script>
	<script src="demo-js/demo.js"></script>
    <script class="example">
		//load all polyfill features
		$.webshims.polyfill();
		
    </script>
	
	<title>Webshims lib - The capability-based polyfill-loading JS library</title>
	    
</head>

<body class="home">

		<header>
			<hgroup>
				<h1>Webshims Lib.</h1>
				<h2>Polyfill only the incapable browsers</h2>
			</hgroup>
			<nav></nav>
		</header>
		<div class="main">
			<section>
				<div class="home-box about-box">
					<p>Webshims Lib is a DOM extension helper which <a href="http://remysharp.com/2010/10/08/what-is-a-polyfill/">polyfills</a> the <a href="http://www.brucelawson.co.uk/2010/meet-newt-new-exciting-web-technologies/">latest and greatest web features</a> in browsers that don't support them natively. It is built on top of <a href="http://jquery.com/">jQuery</a> and <a href="http://www.modernizr.com/">Modernizr 1.7+</a> and needs one of the follwoing script loaders: <a href="http://yepnopejs.com/">yepnope</a>, <a href="https://gist.github.com/936413">SSSL</a> or <a href="http://requirejs.org/">RequireJS</a>.</p>
				</div>
				<div class="home-box download-box">
					<p>
						<a href="http://github.com/aFarkas/webshim/downloads" class="download-button">
							<strong>Download Webshims Lib</strong>
						</a>
					</p>
				</div>
				<div class="home-box concept-box">
				<h3>Main concepts</h3>
					<ul>
						<li><strong>Capability based loading:</strong> the more features a browser supports natively, the more lightweight webshims will be</li>
						<li><strong>Modular feature implementation:</strong> Only load features that you need for your application.</li>
						<li><strong>Future-proof feature detection:</strong> We try to feature detect everything instead of browser sniffing to be more future proof</li>
						<li><strong>Almost pure native and accurate APIs</strong> Helps you to learn HTML5 (Markup-/DOM/JS-APIs) and to build useful abstractions and extensions on top of the standard. Documentation is the specification (e.g. <a href="http://dev.w3.org/html5/html-author/">HTML5 W3C Specification</a>)</li>
						<li><strong>stable and reliable polyfills for current and future x-browser landscape:</strong> webshims lib's polyfills are cross-browser testet and work with incapable, buggy, partial and of course full capable HTML5 implementations.</li>
					</ul>
				</div>
				<div class="feature-example home-box">
					<h3>What makes webshims lib different?</h3>
					<div class="inner-box">
						<p>Did you ever try to dynamically set or get the placeholder or the value attribute of a text input with one of the other placeholder shims? With many of them it doesn't properly work. Webshims strives to provide a uniform and standards-compliant API in every environment.</p>
						<p>The following text input uses the html5 placeholder attribute:</p>
						<form action="#">
							<input class="text" name="placeholder" id="placeholder" placeholder="change me" />
						</form>
						<p>If you're viewing this page in a browser that doesn't support placeholder, Webshims has added this functionality via Javascript, and in a way that preserves your ability to work with the element's properties dynamically:</p>
						<code>$("#placeholder").attr("placeholder", "<input value="test text" class="text" id="placeholder-text" />");</code> <button>run code</button>
						<div class="hidden-explanation">
							<p>Being able to change the placeholder of an input element dynamically isn't  a huge deal, but it shows how webshims lib works. With few exceptions, you won't be able to tell the difference between a shim and a native implementation. In some cases, the shim will even be more standards compliant than some browsers' native implementations.</p>
							<p>The placeholder polyfill also works with getting and setting the value property (many other placeholder polyfills don't support this properly):</p>
							<ul>
								<li><code>$("#placeholder").prop('value')</code></li>
								<li><code>$("#placeholder").val()</code></li>
								<li><code>$("#placeholder").prop('value', 'new value')</code></li>
								<li><code>$("#placeholder").val('new value')</code></li>
							</ul>
						</div>
					</div>
				</div>
				<div class="home-box supported-browser-box">
					<h3>Supported Browsers</h3>
					<ul>
						<li>IE6+</li>
						<li>Firefox 3.6+</li>
						<li>Safari 4+</li>
						<li>Safari for iOS 4.2+</li>
						<li>Chrome 11.0+</li>
						<li>Opera 11+</li>
					</ul>
					
				</div>
				
			</section>
			<section class="feature-overview">
				<hgroup>
					<h2>Features / Demos</h2>
				</hgroup>
				<div>
					<article>
						<h3><a href="demos/shiv.html">Semantic Structure: Shiv solution</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/canvas.html">Canvas</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/webforms.html">HTML5 forms / Webforms 2</a></h3>
					</article>
										
					<article>
						<h3><a href="demos/json-storage.html">JSON.parse / JSON.stringify &amp; localStorage / sessionStorage</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/geolocation.html">Geolocation</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/details.html">interactive elements: details &amp; summary</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/es5.html">ES5/JavaScript 1.8.5</a></h3>
					</article>
				</div>	
			</section>
			<section>
				<hgroup>
					<h2>How to</h2>
				</hgroup>
				<div class="accordion">
				<h3 id="quick-install" class="button">Easy &amp; simple Quick install</h3>
				<div class="panel">
<code class="block">
//reference the base script
&lt;script src="js-webshim/minified/polyfiller.js"&gt;&lt;/script&gt;
	
&lt;script&gt;
	//implement all unsupported features
	$.webshims.polyfill();
	//or load only specific features you need
	//$.webshims.polyfill('forms json-storage');
	
	$(function(){
	//use all implemented API-features on DOM-ready
	});
&lt;/script&gt;		
</code>
				</div>
	
				<h3 id="embed-polyfill" class="button">Embedding and configuring the script</h3>
				<div class="panel">
					<ul>
						<li>Take the 'js-webshim' folder and add it to your project. (You will find a minified and a dev folder there.)</li>
						<li>Include the polyfiller.js into your HTML page. You can concatenate this file with your other js and rename. Don't forget to also include <a href="http://jquery.com">jQuery</a>, <a href="http://www.modernizr.com/">Modernizr</a> and a scriptloader (<a href="http://yepnopejs.com/">yepnope</a>, <a href="https://gist.github.com/936413">SSSL</a> or <a href="http://requirejs.org/">RequireJS</a>).</li>
						<li>call the polyfill method</li>
					</ul>
				
<code class="block">
&lt;script src="js/jquery-1.6.1.js"&gt;&lt;/script&gt;
&lt;script src="js/modernizr-custom.js"&gt;&lt;/script&gt;
&lt;script src="js/yepnope.js"&gt;&lt;/script&gt;
&lt;script src="js-webshim/minified/polyfiller.js"&gt;&lt;/script&gt;


&lt;script&gt;
	//load and implement all unsupported features
	$.webshims.polyfill();
&lt;/script&gt;	
</code>
				
						<p>The polyfill method can also take a whitespace-separated list of several features.</p>
<code class="block">
//load and implement json-storage and geolocation features, if they aren't supported
$.webshims.polyfill('json-storage geolocation');
</code>					
						<h3>List of features</h3>
						
						<ul>
							<li><code>json-storage</code>*</li>
							<li><code>es5</code>*</li>
							<li><code>geolocation</code>*</li>
							<li><code>canvas</code>*</li>
							<li><code>forms</code>*</li>
							<li><code>forms-ext</code></li>
							<li><code>details</code></li>
						</ul>
						<p>The polyfill-method can also take a keyword called <code>lightweight</code>, which will load a filesize-/feature- balanced profile</p>
						<p><small>With an * marked features are part of the lightweight profile</small></p>
	
<code class="block">
//load and implement all unsupported features from the lightweight profile
$.webshims.polyfill('lightweight');
</code>			
						<p>If you have any trouble setting up Webshims lib, set <code>$.webshims.debug</code> to true and open your console:</p>
<code class="block">							
&lt;script&gt;
	$.webshims.debug = true;
	$.webshims.polyfill();
&lt;/script&gt;	
</code>			
					<p>If you dont want any log messsages, simply set <code>$.webshims.debug</code> explicitly to <code>false</code>.</p>
					<h3>Custom Modernizr build</h3>
					<p>Webshims lib does not need every Modernizr test and supports creating a <a href="http://www.modernizr.com/download/#-canvas-input-inputtypes-localstorage-sessionstorage-geolocation-iepp-addtest">custom Modernizr build</a> (All required tests are pre-checked.) (If you want to use yepnope as your script loader please additionally <a href="http://www.modernizr.com/download/#-canvas-input-inputtypes-localstorage-sessionstorage-geolocation-iepp-addtest-load">check Modernizr.load</a>).</p>
					<h3>High Performance loading using combo-handler service</h3>
					<p>Webshims lib supports generating a combohandler - url. Simply pass true or your combohandler options as the second argument. The defaults are fine to use in conjunction with the defaults of the <a href="http://code.google.com/p/minify/">minify - project</a>.</p>
<code class="block">
//loads all features with a combohandler
$.webshims.polyfill(true);
//loads lightweight with a combohandler
$.webshims.polyfill('lightweight', true);
//loads json-storage and geolocation as a combohandler
$.webshims.polyfill('js-storage geolocation', true);
</code>
					<p>You can configure the generated combohandler using the following options</p>
					<ul>
						<li><strong>base</strong>: (default: '/min/f=') The base path to your combohandler-middleware.</li>
						<li><strong>seperator</strong>: (default: ',') the seperator between each js-source</li>
						<li><strong>maxFiles</strong>: (default: 10) the maximum files, that are combined in one combohandler</li>
						<li><strong>scriptPath</strong>: (default: dynamically computed absolute script-path to your shims-folder without a starting slash)</li>
					</ul>
<code class="block">
//loads json-storage and geolocation as a combohandler
$.webshims.polyfill('js-storage geolocation', true);
//would load in IE7: /min/f=path-to-shims/json-storage.js,path-to-shims/geolocation.js
//would load in IE8: /min/f=path-to-shims/geolocation.js
//would load in IE9 and other browsers: nothing :-)

$.webshims.polyfill('js-storage geolocation', {
	seperator: '&',
	base: '/minify.jsp?scripts='
});
//would load in IE7: /minify.jsp?scripts=path-to-shims/json-storage.js&path-to-shims/geolocation.js
//would load in IE8: /minify.jsp?scripts=path-to-shims/geolocation.js
//would load in IE9 and other browsers: nothing :-)
</code>			
<!--
//ToDo: explain combohandler fn-configuration
$.webshims.polyfill({
	fn: function(base, scriptPath, seperator, srces){
		return base + (srces.join(seperator)) +'&b='+(scriptPath.substr(0, scriptPath.length-1));
	}
});	
-->			
					<h4>Some information about "Make fewer HTTP requests"</h4>
					<p>There is a very bad myth, saying that combining all your JS into one file is good for performance. In fact this rule can dramatically slow down loading your page. The <a href="http://calendar.perfplanet.com/2010/thoughts-on-performance/">truth is a little bit more complex</a>.</p>
					<p>This rule was written in 2004 and the reason beyond this rule is that loading JS in old browser like IE6/IE7/FF3.0 do block downloading other resources, do block HTML parsing and do block UI rendering (+ old browser have normally only 2 simultaneous download slots).</p>
					<p>In newer browsers like IE8+/FF3.5+ JS loading do neither block downloading other resources nor block HTML [pre-]parsing (+ they have between 4-8 simultaneous download slots). And in case of using a script loader (and webshims lib is using a script loader) loading scripts won't block anything even in IE6/IE7/FF3.0.</p>
					<p>This said, if you are using a combohandler service you should make sure, that all browsers load between 2-8 JS files (depends on browser and webpage / use the maxFiles configuration to achieve this).</p>
					<p>And if you only want to use some polyfills and not all, you should not use a combohandler, because all polyfill downloads are parallelized.</p>
				</div>
				<h3 id="polyfill-ready" class="button">Fire when ready</h3>
				<div class="panel">
				<p>Not every feature is ready immediately in all browsers; some shims might take time to load before you can use them. You can use one of jQuery's <code>ready</code> methods to delay working with elements until the DOM and any necessary shims are ready.</p>
<code class="block">
$(function(){
	//work with DOM + all implemented features
});

$(doument).ready(function(){
	//work with DOM + all features
});
</code>		
	
			
					<p>If you want to use a feature as soon as possible, you can use <code>$.webshims.ready</code> and pass the feature name(s) and a callback function:</p>
<code class="block">
$.webshims.ready('geolocation json-storage', function(){
	//work with geolocation, JSON and localStorage
});
</code>	
					<p>Note that this callback function may be called before DOM-Ready. If you want to use a feature after DOM-Ready, simply pass the string 'DOM':</p>
<code class="block">
$.webshims.ready('DOM canvas', function(){
	//work with canvas in the document
});
</code>	
				</div>
				<h3 id="polyfill-options" class="button">Setting feature-specific options</h3>
				<div class="panel">
					<p>Some features have additional options which can be configured with the <code>$.webshims.setOptions</code> method. <code>setOptions</code> should always be called before the <code>polyfill</code> method:</p>
<code class="block">
$.webshims.setOptions('canvas', {
	type: "flash" //use flashcanvas instead of excanvas as polyfill
});
</code>		
				
					<p><code>setOptions</code> can also take a single options parameter:</p>
<code class="block">
$.webshims.setOptions({
	//configure canvas-shim
	canvas: {
		type: "flash" // use flashcanvas instead of excanvas as polyfill
	},
	//configure forms-shim
	forms: {
		customMessages: true // implement customValidationMessages
	}
});
</code>	
				</div>
				<h3 id="polyfill-abstractions" class="button">Minor Abstractions to DOM attributes, DOM methods and DOM events</h3>
				<div class="panel">
					<p>Due to the fact that we cannot extend accessors of elements in all browsers, we always use jQuery as an extension-wrapper.</p>
					<ul>
						<li>
							<p><strong>Accessing DOM properties/attribute IDLs</strong>: if the feature allows accessing a specific attribute or property, always use jQuery's built-in <code>$.prop</code> (in case of IDL attributes/properties) or <code>$.attr</code>/<code>$.removeAttr</code> (in case of content attributes) method:</p>
<code class="block">
// instead of accessing a property directly (e.g. this.validity), use $.fn.prop 
$(this).prop('validity');
// or:
//$.prop(this, 'validity');
</code>
						</li>
						<li>
							<p><strong>calling a DOM method</strong>: While DOM properties have to be accessed through jQuery's <code>$.prop/$.attr</code> methods, DOM methods are added to DOM elements themselves, so you can call them directly:</p>
<code class="block">
// "this" refers to a DOM element, not a jQuery object
this.checkValidity();
</code>
							<p>Webshims lib also generates a jQuery plugin which wraps the feature, so you can use jQuery too:</p>
<code class="block">
$(this).checkValidity();
</code>
							<p>If you pass a list of nodes and the method doesn't return anything, the method will be called on each element in this list, otherwise it will be called on the first element.</p>
						</li>
						<li>
							<p><strong>binding to events</strong>: Always use jQuery's <code>bind</code> method to register your event handlers. <code>addEventListener</code> won't work in polyfilled browsers. Most events in the HTML5 specification are so-called simple events. Simple events do not bubble. Due to the fact that developers really like event delegation and jQuery cannot distinguish between the event phases (capturing/propagation), we use event capturing in the native implementation and <code>$.fn.trigger</code> in the shim.</p>
							<p>This means that some HTML5 events go down the DOM tree in capable browsers and go up the tree in polyfilled browsers. This can create differences if you are calling <code>event.stopPropagation();</code> or <code>return false;</code> in your event handler. If you only want to prevent the default, don't use <code>return false;</code>, use <code>event.preventDefault();</code> instead.</p>
						</li>
						<li>
							<p><strong>manipulation methods</strong>: To insert new HTML5 content dynamically, use <code>.htmlWebshim()</code>, <code>.appendWebshim()</code>, <code>.prependWebshim()</code>, <code>.afterWebshim()</code>, <code>.beforeWebshim()</code> and <code>.replaceWithWebshim()</code>:</p>
<code class="block">
//three different examples
$('form').appendWebshim('&lt;input type="date" /&gt;');
$('#canvas-box').htmlWebshim('&lt;canvas&gt;&lt;/canvas&gt;');
$('datalist#list select').prependWebshim('&lt;option value="new suggestion item" /&gt;');
</code>
						</li>
						<li>
							<p><strong>no shadowdom</strong>: Webshims lib sometime has to add additional DOM elements to mimic the UI of HTML5 elements. This can sometimes create differences, between polyfilled and non polyfilled browsers. Webshims lib gives you a method called 'getShadowElement' to access the shadowelement from the native element and a method called 'getNativeElement' to access the native element from the shadowelement. If the element has no shadowelement the element itself is returned.</p>
							
<code class="block">
//animate the width of all date - inputs to a width of 300
$('input[type="date"]').getShadowElement().animate({width: 300});
</code>
						</li>
					</ul>
					</div>
					<h3 id="implement-polyfill" class="button">How to write a new feature implementation?</h3>
					<div class="panel">
						<p>A Pollyfill is always split into at least two parts. First the test and loader definition, and then the implementation.</p>
		
		<p>Assume there is a new method <code>magicMethod</code> on the window object that we want to polyfill if the browser doesn't provide it. An implementation would look like this:</p>
<code class="block">
$.webshims.addPolyfill('magicMethod', {
	test: function(){
		return ('magicMethod' in window);	
	}
});
// loads magicMethod.js from shim-folder if test returns false
</code>		
		<p>Create a file called magicMethod with your polyfill code and place it in the shim folder:</p>	
<code class="block">
window.magicMethod = function(){
	//your polyfill implementation
};
</code>		

		<p>If your implementation has dependencies on other polyfills/modules, you can add a dependencies property to make sure they're loaded too:</p>
		
<code class="block">
$.webshims.addPolyfill('magicMethod', {
	test: function(){
		return ('magicMethod' in window);	
	},
	dependencies: ['es5', 'json-storage']
});
// load magicMethod.js and its dependencies if test returns false
</code>		
		<p>If your shim has dependencies, you have to register your implementation code with <code>$.webshims.register</code>:</p>	
<code class="block">
jQuery.webshims.register('magicMethod', function($, webshims, window, document, undefined, options){
	//now you can use es5-feature and json-storage feature	
	window.magicMethod = function(){
		//your polyfill implementation
	};
});
</code>	

		<p>In case of a DOM extension, webshims lib comes with some useful extension-methods.</p>
<code class="block">
$.webshims.addPolyfill('mediaelement', {
	test: function(){
		return ('canPlayType' in document.createElement('video'));	
	},
	dependencies: ['dom-support'],
	methodNames: ['play'] //pause, load
});
// load mediaelement.js and DOM extension features from shim folder
// if test returns false and always create a jQuery plugin called play,
// which tries to invoke native or polyfilled play

// listen to 'play' events in the capturing phase
// can use event delegation with jQuery's bind method
$.webshims.capturingEvents(['play']);
</code>

		<p>Now put a mediaelement.js inside of your shim folder and start implementing some features. The <code>dom-support</code> feature of Webshims lib comes with some very useful implementation helpers. Here are two of them:</p>
		<ul>
			<li><code>$.webshims.defineNodeNamesProperty</code> (nodeNames, property, descriptor)</li>
			<li><code>$.webshims.defineNodeNamesBooleanProperty</code> (nodeNames, property, descriptor)</li>
		</ul>
		<p>Note: The API will change a little bit with jQuery 1.6, because we have then to distinguish between content and IDL attributes.</p>
<code class="block">
//wait till the DOM-Extension feature is loaded
jQuery.webshims.register('mediaelement', function($, webshims, window, document, undefined, options){
	//note: webshims refers to jQuery.webshims in this function
	
	//Implements a new IDL property on audio, video called currentTime
	webshims.defineNodeNamesProperty('audio, video', 'currentTime', {
		prop: {
			get: function(){
				//your getter implementation ("this" refers to the element)
			},
			set: function(value){
				//your setter implementation ("this" refers to the element)
			}
		}
	});
	
	//Implements a new constant property called HAVE_CURRENT_DATA on audio, video
	webshims.defineNodenamesProperty('audio, video', 'HAVE_CURRENT_DATA', {
		prop: {
			value: 2
		}
	});
	
	//Implements a new method called play on audio, video
	webshims.defineNodeNamesProperty('audio, video', 'play', {
		prop: {
			value: function(){
				//your play method implementation
				//this refers to the element
			}
		}
	});
	
	
	
	//Implements a new boolean IDL property called controls on audio, video
	//which is reflected by a content attribute
	webshims.defineNodeNamesBooleanProperty('audio, video', 'controls', {
		//set works more like an onSet:
		//you don't have to set the value anymore on the DOM node, only handle true/false values
		set: function(value){
			if(value){
				//show controls for elem
			} else {
				//hide controls for elem
			}
		},
		initAttr: true
	});
});	
</code>
		
					</div>
					
					<h3 id="polyfill-foucs" class="button">Dealing with FOUCs</h3>
					<div class="panel">
						<p>Webshims lib uses a script loader and loading scripts dynamically always have the potential to create so called Flash of unstyled contents or Flash of unbehaviored contents.</p>
						<p>There are a lot ways to deal with FOUCs/FOUBCs. The most easiest way to remove FOUCs caused by webshims lib is:</p>
						<ol>
							<li>Put your JS into your head and call $.webshims.polyfill() immediately (before DOM-Ready)</li>
							<li>Put the following CSS in your Stylesheet:
<code class="block">
/* 
The class loading-polyfills is set after you have called polyfill
and will be removed as soon as all polyfills are loaded and implemented
*/
.loading-polyfills body {
	visibility: hidden;
}
/*
If polyfilling takes longer as 600ms, an additional class called 'long-loading-polyfill' will be set
It's good practice to show the user that something is going on in this case
*/
html.long-loading-polyfills {
	background-image: url(polyfill-loader.gif);
	background-position: center 240px;
	background-repeat: no-repeat;
}
</code>
							</li>
						</ol>
						
						<p>If you still have FOUCs you can additionally change the <code>removeFOUC</code> configuration to true. In this case the loading classes added by webshims lib, won't be removed, if all requested features are loaded and polyfilled. Webshims lib will additionally wait for the DOM-Ready event.</p>
<code class="block">
$.webshims.setOptions('removeFOUC', true);
</code>
						<p><small>Note: The added classes are bulletproof. In case of an error or window's load event the loading-classes will be removed, even if not all features seem to be implemented.</small></p>
						
						<h4>Why you should put your webshims inside of your documents head</h4>
						<p>There is a lot of misunderstanding about the yslow rule "Put your JavaScript at the bottom". Put your JavaScript at the bottom does not decrease total page load time. The effect is psychologic. The user sooner sees how the page is loading, because JS blocks the UI rendering.</p>
						<p>This also means that a FOUC is not a side effect of "Put your JavaScript at the bottom". It is the intended effect of this technique.</p>
						<p>Using a script loader (and webshims lib uses a script loader) has a very similiar effect and combining both techniques will increase FOUCs.</p>
						<p>If you use a script loader and put your JS at top you have done everything right about performance. Some versions of yslow recognize that you have used this technique and won't subtract points for this rule ("Put your JavaScript at the bottom"). The nice thing about script loaders is, that loading JS-files dynamically will additionally decrease page load time, because all browsers can parallelize script loading.</p>
					</div>
					
					<h3 id="polyfill-philosophy" class="button">Webshims polyfilling philosophy</h3>
					<div class="panel">
						<h4>Abstractions vs. Polyfills</h4>
						<p>A polyfill is a shim that mimics/replicates a future/standarized API using legacy techniques to older browsers. A "shim-abstraction" is a code that uses modern and legacy techniques to create a new unstandardized API.</p>
						<p>An abstraction can have several advantages over a pure polyfill. One of those advantages is a more clean and more easy-to-use API. Webshims Lib has decided to create/use polyfills (with some extensions on top of the standard, not instead!). This decision has several reasons.</p>
						<p><strong>Make learning new web technologies easy</strong>: It's an easy question: Do you want to learn proprietary or standardized code.</p>
						<p><strong>Make interoperability easy</strong>: Although Webshims Lib technique to create DOM-Setters and DOM-Getters is an abstraction (always use $.attr to get/set DOM-Attributes). This abstraction is compatible to HTML5-browsers and makes writing interoperable code easy. Which means, you can use and mix different code of different developers.</p>
						<p><strong>Make extensions easy</strong>: If you want to create an extension on top of a feature, you always have one code path, because everything (including the low-level API) should be polyfilled. If you want to extend an abstraction, it might be possible, that you have to extend several code paths (modern and legacy code).</p>
						<p><strong>Let the user/developer choose</strong>: Webshims lib's polyfills are loaded modular by demand, which means you can mix several polyfills. Consider the following:</p>
						<p>A plugin-author needs a storage API and he chooses abstraction code A, because it is good, has an awsome API and is only 5kb. Another plugin author also needs an storage API and uses abstraction code B, it's also nice and also just 5kb. And now you need to use both scripts and you are adding 10kb of useless code, because 80% of all browser already support localStorage and JSON (I would say this is a big fail).</p>
						
						<h4>Create stable, reliable polyfills</h4>
						<p>One big problem in the "polyfilling" world are reliable and production ready polyfills. Webshims Lib takes cross-browser testing and studying the specifications very serious.</p>
						<h4>Improve the standard</h4>
						<p>While Webshims lib's polyfills only want to polyfill the gaps and in some cases do some extension work. Every developer is invited to abstract ugly APIs, to re-style ugly polyfilled UI components or/and to write extensions on top of the standard. If you are doing so, please be so kind and share your code with others.</p>
						
					</div>
				</div>
			</section>
			
				
			<section>
				<hgroup>
					<h2>Further Development</h2>
					<h3>Feel free to <a href="https://github.com/aFarkas/webshim#fork_box">fork</a>, <a href="https://github.com/aFarkas/webshim/issues">report issues</a>, develop implementations/features, develop extensions on top of implemented featues or simply use :-).</h3>
				</hgroup>
				
				<ul>
					<li>improve current implementations</li>
					<li><a href="http://www.w3.org/TR/html5/video.html">audio/video</a> implementation (coming in 1.9)</li>
					<li>history (pushState etc.)/hashchange (maybe <a href="https://github.com/balupton/history.js">history.js</a> (coming in 1.9))</li>
					<li>make everything more native (this will be more awsome!!! coming in 2.0)</li>
				</ul>
				
			</section>
		</div>
		<footer>
			<small>
				<strong>Note</strong>: every polyfill is a hack! innovative frontend development is hacky and always will be hacky!
			</small>
		</footer>
<!--[if lte IE 7]>
	<div class="browser-support"> 			
		<div class="browser-support-box"> 				
			Webshims Lib really cares about cross browser support and supports all A-Graded Browsers including IE6 and newest Opera. But I don't care about Styling/Layout issues in IE7- on this demo page.
		</div> 		
	</div>
<![endif]-->
</body>
</html>   
